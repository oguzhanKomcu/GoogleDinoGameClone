<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dino Runner â€” HTML Tek Sayfa</title>
  <style>
    :root {
      --bg: #fff;
      --fg: #222;
      --accent: #4caf50;
      --muted: #bbb;
      --danger: #e53935;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg); color: var(--fg);
      display: grid; place-items: center;
    }
    .wrap {
      width: min(1200px, 98vw);
      padding: 16px;
    }
    h1 { font-size: clamp(18px, 3vw, 24px); margin: 0 0 8px; text-align: center; }
    .panel {
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px; flex-wrap: wrap; margin-bottom: 8px;
    }
    .panel .left, .panel .right { display: flex; align-items: center; gap: 10px; }
    .btn { border: 1px solid var(--fg); background: transparent; padding: 8px 12px; border-radius: 12px; cursor: pointer; }
    .btn:active { transform: translateY(1px); }
    .hint { color: #666; font-size: 14px; }
    canvas { width: 100%; height: auto; display: block; border: 1px solid #ddd; border-radius: 14px; background: #fafafa; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸ¦– Dino Runner (Google Dino Klonu)</h1>
    <div class="panel">
      <div class="left">
        <button id="startBtn" class="btn">BaÅŸlat / Yeniden BaÅŸlat</button>
        <button id="pauseBtn" class="btn">Duraklat / Devam</button>
      </div>
      <div class="right hint">
        <span>Kontroller: â¬†/Space = ZÄ±pla Â· â¬‡ = EÄŸil Â· Mobil: Ekrana Dokun</span>
      </div>
    </div>
    <canvas id="game" width="1200" height="350" aria-label="Dino Game" role="img"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resizeCanvas() {
      const logicalW = 1200; const logicalH = 350;
      canvas.width = logicalW * DPR; canvas.height = logicalH * DPR;
      canvas.style.width = logicalW + 'px'; canvas.style.height = logicalH + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const GROUND_Y = 300;
    const GRAVITY = 2000;
    const JUMP_VELOCITY = 720;
    const DUCK_HEIGHT = 26;
    const RUN_HEIGHT = 42;

    let lastTime = 0;
    let running = false;
    let paused = false;

    const state = {
      speed: 300,
      maxSpeed: 900,
      speedIncrease: 0.05,
      distance: 0,
      score: 0,
      hi: Number(localStorage.getItem('dino_hi') || 0),
      gameOver: false,
    };

    const player = {
      x: 80, y: GROUND_Y, w: 40, h: RUN_HEIGHT,
      vy: 0, onGround: true, ducking: false,
      animTime: 0,
    };

    const obstacles = [];
    const clouds = [];
    const particles = [];

    function rand(min, max) { return Math.random() * (max - min) + min; }

    function resetGame() {
      state.speed = 320; state.distance = 0; state.score = 0; state.gameOver = false; paused = false;
      player.y = GROUND_Y; player.vy = 0; player.onGround = true; player.ducking = false; player.h = RUN_HEIGHT;
      obstacles.length = 0; clouds.length = 0; particles.length = 0;
      for (let i = 0; i < 5; i++) addCloud(rand(0, 1200));
    }

    function drawGround(offset) {
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0 - (offset % 40), GROUND_Y + 1);
      for (let x = -40; x < canvas.width; x += 40) {
        ctx.lineTo(x + 20 - (offset % 40), GROUND_Y + 1);
        ctx.moveTo(x + 40 - (offset % 40), GROUND_Y + 1);
      }
      ctx.stroke();

      ctx.fillStyle = '#c8c8c8';
      for (let i = 0; i < 6; i++) {
        const rx = ((i * 200 + offset * 0.8) % 1240) - 20;
        ctx.fillRect(rx, GROUND_Y + rand(4, 8), rand(3, 6), 2);
      }
    }

    function drawPlayer() {
      const { x, y, w, h, ducking } = player;
      ctx.save();
      ctx.translate(x, y - h);
      ctx.fillStyle = '#222';
      ctx.fillRect(0, 0, w, h);
      ctx.fillRect(w - 16, 6, 18, 18);
      ctx.clearRect(w - 6, 12, 4, 4);
      const t = (player.animTime % 0.25) / 0.25;
      if (!ducking) {
        if (t < 0.5) ctx.fillRect(6, h - 10, 8, 10);
        else ctx.fillRect(20, h - 10, 8, 10);
      } else {
        ctx.fillRect(10, h - 8, 22, 8);
      }
      ctx.restore();
    }

    function addCloud(xStart) {
      clouds.push({ x: xStart || canvas.width + rand(0, 200), y: rand(40, 140), v: rand(10, 30), s: rand(30, 60) });
    }
    function drawClouds(dt) {
      ctx.fillStyle = '#e0e0e0';
      for (let i = clouds.length - 1; i >= 0; i--) {
        const c = clouds[i];
        c.x -= c.v * dt;
        if (c.x < -100) { clouds.splice(i, 1); addCloud(); continue; }
        const s = c.s;
        ctx.beginPath();
        ctx.arc(c.x, c.y, s * 0.6, 0, Math.PI * 2);
        ctx.arc(c.x + s * 0.6, c.y + 5, s * 0.5, 0, Math.PI * 2);
        ctx.arc(c.x - s * 0.6, c.y + 8, s * 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function spawnObstacle() {
      if (Math.random() < 0.7) {
        const width = rand(18, 26) * Math.floor(rand(1, 3));
        const height = rand(28, 48);
        obstacles.push({ type: 'cactus', x: canvas.width + 20, y: GROUND_Y, w: width, h: height, passed: false });
      } else {
        const heightLevel = Math.random() < 0.5 ? GROUND_Y - 30 : GROUND_Y - 70;
        obstacles.push({ type: 'bird', x: canvas.width + 20, y: heightLevel, w: 34, h: 24, flap: 0, passed: false });
      }
    }

    let spawnTimer = 0;
    function updateObstacles(dt) {
      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        spawnTimer = rand(0.9, 1.6) * (state.speed > 700 ? 0.9 : 1);
        spawnObstacle();
      }
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.x -= state.speed * dt;
        if (o.type === 'bird') o.flap += dt * 10;
        if (o.x + o.w < -20) obstacles.splice(i, 1);
        else if (!o.passed && o.x + o.w < player.x) { o.passed = true; state.score += 1; }
      }
    }

    
    function drawObstacles() {
      for (const o of obstacles) {
        if (o.type === 'cactus') {
          ctx.fillStyle = '#2e7d32';
          ctx.fillRect(o.x, o.y - o.h, o.w, o.h);
          ctx.fillStyle = '#1b5e20';
          for (let i = 4; i < o.h; i += 10) ctx.fillRect(o.x + 2, o.y - i, o.w - 4, 2);
        } else {
          ctx.fillStyle = '#444';
          const wing = Math.sin(o.flap) > 0 ? 8 : -6;
          ctx.fillRect(o.x, o.y - o.h, o.w, o.h);
          ctx.fillRect(o.x - 8, o.y - 6, 12, 2 + wing * 0.2);
          ctx.clearRect(o.x + o.w - 6, o.y - o.h + 6, 4, 4);
        }
      }
    }

    function addDust(x, y) {
      for (let i = 0; i < 6; i++) {
        particles.push({ x, y, vx: rand(-30, 30), vy: rand(-10, -60), life: rand(0.25, 0.5) });
      }
    }
    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt; if (p.life <= 0) { particles.splice(i, 1); continue; }
        p.x += p.vx * dt; p.y += p.vy * dt; p.vy += 500 * dt;
      }
    }
    function drawParticles() {
      ctx.fillStyle = '#bdbdbd';
      for (const p of particles) ctx.fillRect(p.x, p.y, 2, 2);
    }

    function rectsOverlap(a, b) {
      return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y <= b.y - b.h || a.y - a.h >= b.y);
    }

    function checkCollision() {
      const box = { x: player.x, y: player.y, w: player.w, h: player.h };
      for (const o of obstacles) {
        const hit = rectsOverlap(box, o);
        if (hit) return true;
      }
      return false;
    }

    function updatePlayer(dt) {
      player.animTime += dt * (player.ducking ? 12 : 8);
      if (!player.onGround) {
        player.vy -= GRAVITY * dt;
        player.y -= player.vy * dt;
        if (player.y >= GROUND_Y) {
          player.y = GROUND_Y; player.onGround = true; player.vy = 0; addDust(player.x + 10, GROUND_Y);
        }
      }
      player.h = player.ducking && player.onGround ? DUCK_HEIGHT : RUN_HEIGHT;
    }

    function updateScoreAndSpeed(dt) {
      state.distance += state.speed * dt;
      state.speed = Math.min(state.maxSpeed, state.speed * (1 + state.speedIncrease * dt));
      if (Math.floor(state.distance / 100) > state.score) state.score = Math.floor(state.distance / 100);
    }

    function formatScore(n) { return String(Math.floor(n)).padStart(5, '0'); }

    function drawHUD() {
      ctx.fillStyle = '#222';
      ctx.font = '16px monospace';
      ctx.textAlign = 'right';
      ctx.fillText(`SCORE ${formatScore(state.score)}`, canvas.width / DPR - 16, 26);
      ctx.fillStyle = '#666';
      ctx.fillText(`HI ${formatScore(state.hi)}`, canvas.width / DPR - 16, 46);
    }

    function drawGameOver() {
      if (!state.gameOver) return;
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fillRect(0, 0, canvas.width / DPR, canvas.height / DPR);
      ctx.fillStyle = '#222';
      ctx.textAlign = 'center';
      ctx.font = 'bold 28px system-ui, sans-serif';
      ctx.fillText('OYUN BÄ°TTÄ°', canvas.width / (2*DPR), 90);
      ctx.font = '16px system-ui, sans-serif';
      ctx.fillText('Space veya BaÅŸlat ile yeniden oynayÄ±n', canvas.width / (2*DPR), 120);
      ctx.restore();
    }

    function loop(ts) {
      if (!running) return;
      const dt = Math.min(0.05, (ts - lastTime) / 1000 || 0);
      lastTime = ts;

      if (!paused && !state.gameOver) {
        updatePlayer(dt);
        updateObstacles(dt);
        updateParticles(dt);
        updateScoreAndSpeed(dt);
        if (checkCollision()) {
          state.gameOver = true; state.hi = Math.max(state.hi, state.score); localStorage.setItem('dino_hi', state.hi);
        }
      }

      ctx.clearRect(0, 0, canvas.width / DPR, canvas.height / DPR);
      drawClouds(dt);
      drawGround(state.distance);
      drawParticles();
      drawObstacles();
      drawPlayer();
      drawHUD();
      drawGameOver();

      requestAnimationFrame(loop);
    }

    function start() {
      resetGame(); running = true; lastTime = performance.now(); requestAnimationFrame(loop);
    }
    function restart() {
      resetGame();
    }

    function jump() {
      if (state.gameOver) { restart(); return; }
      if (player.onGround) { player.vy = JUMP_VELOCITY; player.onGround = false; }
    }
    function duck(on) {
      player.ducking = on && player.onGround;
    }

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); jump(); }
      if (e.code === 'ArrowDown') { e.preventDefault(); duck(true); }
      if (e.code === 'KeyP') { togglePause(); }
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowDown') { duck(false); }
    });

    canvas.addEventListener('pointerdown', () => jump());

    document.getElementById('startBtn').addEventListener('click', () => {
      if (!running) start(); else restart();
    });
    function togglePause() {
      if (state.gameOver) return;
      paused = !paused;
    }
    document.getElementById('pauseBtn').addEventListener('click', togglePause);

    window.addEventListener('blur', () => { paused = true; });

    start();
  </script>
</body>
</html>
